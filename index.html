<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solomon AGI - Bouncing Ball in Rotating Box</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #222;
            color: #fff;
            font-family: Arial, sans-serif;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 250px;
        }

        #controls button {
            padding: 8px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        #controls button:hover {
            background: #45a049;
        }

        #controls label {
            font-size: 12px;
            margin-top: 5px;
        }

        #controls input[type="range"] {
            width: 100%;
        }

        #controls input[type="color"] {
            width: 50px;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #fps {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 4px;
            font-size: 14px;
        }

        canvas {
            border: 1px solid #444;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="startPause">Start</button>
        <button id="reset">Reset</button>
        
        <label for="gravity">Gravity:</label>
        <input type="range" id="gravity" min="0" max="20" step="0.1" value="9.8">
        <span id="gravityValue">9.8</span> m/sÂ²
        
        <label for="damping">Damping:</label>
        <input type="range" id="damping" min="0" max="1" step="0.01" value="0.9">
        <span id="dampingValue">0.9</span>
        
        <label for="rotationSpeed">Rotation Speed:</label>
        <input type="range" id="rotationSpeed" min="0" max="10" step="0.1" value="1">
        <span id="rotationSpeedValue">1</span> rad/s
        
        <label for="ballCount">Ball Count:</label>
        <input type="range" id="ballCount" min="1" max="10" step="1" value="1">
        <span id="ballCountValue">1</span>
        
        <label for="ballSize">Ball Size:</label>
        <input type="range" id="ballSize" min="5" max="30" step="1" value="10">
        <span id="ballSizeValue">10</span> px
        
        <label for="ballColor">Ball Color:</label>
        <input type="color" id="ballColor" value="#ff6b6b">
    </div>
    
    <div id="fps">FPS: <span id="fpsValue">0</span></div>
    
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth - 50;
        canvas.height = window.innerHeight - 50;

        // Control elements
        let startPauseButton = document.getElementById('startPause');
        let resetButton = document.getElementById('reset');
        let gravitySlider = document.getElementById('gravity');
        let dampingSlider = document.getElementById('damping');
        let rotationSpeedSlider = document.getElementById('rotationSpeed');
        let ballCountSlider = document.getElementById('ballCount');
        let ballSizeSlider = document.getElementById('ballSize');
        let ballColorInput = document.getElementById('ballColor');

        // Value displays
        let gravityValue = document.getElementById('gravityValue');
        let dampingValue = document.getElementById('dampingValue');
        let rotationSpeedValue = document.getElementById('rotationSpeedValue');
        let ballCountValue = document.getElementById('ballCountValue');
        let ballSizeValue = document.getElementById('ballSizeValue');
        let fpsDisplay = document.getElementById('fpsValue');

        // Physics parameters
        let gravity = parseFloat(gravitySlider.value) * 100; // Scale for pixels
        let damping = parseFloat(dampingSlider.value);
        let rotationSpeed = parseFloat(rotationSpeedSlider.value) * 0.01;
        let ballCount = parseInt(ballCountSlider.value);
        let ballSize = parseInt(ballSizeSlider.value);
        let ballColor = ballColorInput.value;

        // Game state
        let box = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            width: 400,
            height: 400,
            angle: 0
        };

        let balls = [];
        let running = false;
        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = performance.now();

        // Create ball object
        function createBall(x, y, radius, color) {
            return {
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 200,
                vy: 0,
                radius: radius,
                color: color,
                trail: []
            };
        }

        // Initialize balls
        function initBalls() {
            balls = [];
            for (let i = 0; i < ballCount; i++) {
                let x = box.x + (Math.random() - 0.5) * (box.width - ballSize * 2);
                let y = box.y + (Math.random() - 0.5) * (box.height - ballSize * 2);
                balls.push(createBall(x, y, ballSize, ballColor));
            }
        }

        // Update control values
        function updateControls() {
            gravityValue.textContent = gravitySlider.value;
            dampingValue.textContent = dampingSlider.value;
            rotationSpeedValue.textContent = rotationSpeedSlider.value;
            ballCountValue.textContent = ballCountSlider.value;
            ballSizeValue.textContent = ballSizeSlider.value;
        }

        // Event listeners
        gravitySlider.addEventListener('input', function() {
            gravity = parseFloat(this.value) * 100;
            updateControls();
        });

        dampingSlider.addEventListener('input', function() {
            damping = parseFloat(this.value);
            updateControls();
        });

        rotationSpeedSlider.addEventListener('input', function() {
            rotationSpeed = parseFloat(this.value) * 0.01;
            updateControls();
        });

        ballCountSlider.addEventListener('input', function() {
            ballCount = parseInt(this.value);
            initBalls();
            updateControls();
        });

        ballSizeSlider.addEventListener('input', function() {
            ballSize = parseInt(this.value);
            balls.forEach(ball => ball.radius = ballSize);
            updateControls();
        });

        ballColorInput.addEventListener('input', function() {
            ballColor = this.value;
            balls.forEach(ball => ball.color = ballColor);
        });

        startPauseButton.addEventListener('click', function() {
            running = !running;
            this.textContent = running ? 'Pause' : 'Start';
        });

        resetButton.addEventListener('click', function() {
            initBalls();
            box.angle = 0;
            running = false;
            startPauseButton.textContent = 'Start';
        });

        // Rotate point around origin
        function rotatePoint(x, y, angle, originX, originY) {
            let cosA = Math.cos(angle);
            let sinA = Math.sin(angle);
            let dx = x - originX;
            let dy = y - originY;
            return {
                x: dx * cosA - dy * sinA + originX,
                y: dx * sinA + dy * cosA + originY
            };
        }

        // Check if point is inside rotated box
        function isPointInRotatedBox(px, py, box) {
            // Transform point to box's local coordinates
            let angle = -box.angle;
            let translated = rotatePoint(px, py, angle, box.x, box.y);
            let localX = translated.x - box.x;
            let localY = translated.y - box.y;
            
            return Math.abs(localX) <= box.width / 2 && Math.abs(localY) <= box.height / 2;
        }

        // Handle ball-box collision
        function handleBoxCollision(ball, box, dt) {
            // Transform ball to box's local coordinates
            let angle = -box.angle;
            let translated = rotatePoint(ball.x, ball.y, angle, box.x, box.y);
            let localX = translated.x - box.x;
            let localY = translated.y - box.y;
            
            // Check each wall
            let collision = false;
            let normal = { x: 0, y: 0 };
            
            // Left wall
            if (localX - ball.radius < -box.width / 2) {
                localX = -box.width / 2 + ball.radius;
                normal.x = 1;
                collision = true;
            }
            // Right wall
            else if (localX + ball.radius > box.width / 2) {
                localX = box.width / 2 - ball.radius;
                normal.x = -1;
                collision = true;
            }
            
            // Top wall
            if (localY - ball.radius < -box.height / 2) {
                localY = -box.height / 2 + ball.radius;
                normal.y = 1;
                collision = true;
            }
            // Bottom wall
            else if (localY + ball.radius > box.height / 2) {
                localY = box.height / 2 - ball.radius;
                normal.y = -1;
                collision = true;
            }
            
            if (collision) {
                // Transform position back to world coordinates
                let worldPos = rotatePoint(localX + box.x, localY + box.y, box.angle, box.x, box.y);
                ball.x = worldPos.x;
                ball.y = worldPos.y;
                
                // Transform normal to world coordinates
                let worldNormal = rotatePoint(normal.x, normal.y, box.angle, 0, 0);
                
                // Reflect velocity
                let dot = ball.vx * worldNormal.x + ball.vy * worldNormal.y;
                ball.vx = (ball.vx - 2 * dot * worldNormal.x) * damping;
                ball.vy = (ball.vy - 2 * dot * worldNormal.y) * damping;
                
                // Add rotation effect
                let tangent = { x: -worldNormal.y, y: worldNormal.x };
                let rotationEffect = rotationSpeed * box.width * 0.5;
                ball.vx += tangent.x * rotationEffect;
                ball.vy += tangent.y * rotationEffect;
            }
        }

        // Update ball physics
        function updateBall(ball, dt) {
            // Apply gravity
            ball.vy += gravity * dt;
            
            // Update position
            ball.x += ball.vx * dt;
            ball.y += ball.vy * dt;
            
            // Add to trail
            ball.trail.push({ x: ball.x, y: ball.y });
            if (ball.trail.length > 30) {
                ball.trail.shift();
            }
            
            // Check collision with box
            handleBoxCollision(ball, box, dt);
        }

        // Draw box
        function drawBox(box) {
            ctx.save();
            ctx.translate(box.x, box.y);
            ctx.rotate(box.angle);
            
            // Draw 3D effect
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.strokeRect(-box.width / 2, -box.height / 2, box.width, box.height);
            
            // Draw corners for 3D effect
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 5;
            let cornerSize = 20;
            // Top-left
            ctx.beginPath();
            ctx.moveTo(-box.width / 2, -box.height / 2 + cornerSize);
            ctx.lineTo(-box.width / 2, -box.height / 2);
            ctx.lineTo(-box.width / 2 + cornerSize, -box.height / 2);
            ctx.stroke();
            
            // Top-right
            ctx.beginPath();
            ctx.moveTo(box.width / 2 - cornerSize, -box.height / 2);
            ctx.lineTo(box.width / 2, -box.height / 2);
            ctx.lineTo(box.width / 2, -box.height / 2 + cornerSize);
            ctx.stroke();
            
            // Bottom-right
            ctx.beginPath();
            ctx.moveTo(box.width / 2, box.height / 2 - cornerSize);
            ctx.lineTo(box.width / 2, box.height / 2);
            ctx.lineTo(box.width / 2 - cornerSize, box.height / 2);
            ctx.stroke();
            
            // Bottom-left
            ctx.beginPath();
            ctx.moveTo(-box.width / 2 + cornerSize, box.height / 2);
            ctx.lineTo(-box.width / 2, box.height / 2);
            ctx.lineTo(-box.width / 2, box.height / 2 - cornerSize);
            ctx.stroke();
            
            ctx.restore();
        }

        // Draw ball with gradient
        function drawBall(ball) {
            // Draw trail
            if (ball.trail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(ball.trail[0].x, ball.trail[0].y);
                for (let i = 1; i < ball.trail.length; i++) {
                    let alpha = i / ball.trail.length * 0.3;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.lineTo(ball.trail[i].x, ball.trail[i].y);
                }
                ctx.stroke();
            }
            
            // Draw ball with gradient
            let gradient = ctx.createRadialGradient(
                ball.x - ball.radius * 0.3, 
                ball.y - ball.radius * 0.3, 
                0,
                ball.x, 
                ball.y, 
                ball.radius
            );
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.3, ball.color);
            gradient.addColorStop(1, adjustColor(ball.color, -50));
            
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Add rim
            ctx.strokeStyle = adjustColor(ball.color, -100);
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // Adjust color brightness
        function adjustColor(color, amount) {
            let num = parseInt(color.replace('#', ''), 16);
            let r = Math.max(0, Math.min(255, (num >> 16) + amount));
            let g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
            let b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
            return '#' + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        // Animation loop
        function animate(currentTime) {
            let dt = (currentTime - lastTime) / 1000;
            dt = Math.min(dt, 0.02); // Cap delta time
            lastTime = currentTime;
            
            // Clear canvas
            ctx.fillStyle = 'rgba(17, 17, 17, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (running) {
                // Update box rotation
                box.angle += rotationSpeed;
                
                // Update balls
                balls.forEach(ball => updateBall(ball, dt));
            }
            
            // Draw everything
            drawBox(box);
            balls.forEach(ball => drawBall(ball));
            
            // Update FPS
            frameCount++;
            if (currentTime - fpsTime >= 1000) {
                fpsDisplay.textContent = frameCount;
                frameCount = 0;
                fpsTime = currentTime;
            }
            
            requestAnimationFrame(animate);
        }

        // Initialize
        initBalls();
        updateControls();
        requestAnimationFrame(animate);
    </script>
</body>
</html> 
